<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simula√ß√£o de Gargalo - Teoria das Filas</title>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .container { max-width: 1400px; margin: 0 auto; background: rgba(255,255,255,0.1); border-radius: 20px; padding: 20px; backdrop-filter: blur(10px); box-shadow: 0 8px 32px rgba(0,0,0,0.3); width: 100%; box-sizing: border-box; }
        .footer { text-align: center; }
        .footer a:link { color:white; text-decoration: none; }
         .footer a:hover { color:white; text-decoration: underline; }
        h1 { text-align: center; margin-bottom: 30px; font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .controls { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-bottom: 30px; }
        .control-group { background: rgba(255,255,255,0.15); padding: 15px; border-radius: 10px; display: flex; align-items: center; gap: 10px; }
        .control-group label { white-space: nowrap; }
        .control-group input[type=number] { width: 60px; border-radius: 5px; border: none; padding: 5px; color: #333; }
        .control-group input[type=checkbox] { transform: scale(1.2); }
        button { background: linear-gradient(45deg, #ff6b6b, #ee5a24); color: white; border: none; padding: 12px 24px; border-radius: 25px; cursor: pointer; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        button:disabled { background: rgba(255,255,255,0.2); cursor: not-allowed; transform: none; box-shadow: none; }
        .simulation-area { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stage { background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px; min-height: 400px; border: 2px solid rgba(255,255,255,0.2); position: relative; display: flex; flex-direction: column; align-items: center; }
        .stage-header { text-align: center; margin-bottom: 10px; width: 100%; }
        .queue-count { position: absolute; top: -10px; right: -10px; background: #e74c3c; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .worker { background: rgba(255,255,255,0.2); border-radius: 10px; padding: 10px; margin: 10px 0; width: 90%; text-align: center; }
        .worker.working { background: rgba(52,152,219,0.7); animation: pulse 2s infinite; }
        .worker.idle { background: rgba(149,165,166,0.5); }
        .worker.unavailable { background: rgba(255,165,0,0.7); animation: none; } /* Orange for unavailable */
        @keyframes pulse { 0%,100%{transform:scale(1);}50%{transform:scale(1.02);} }
        .task { background: linear-gradient(45deg,#3498db,#2ecc71); color: white; padding: 8px 12px; margin: 5px auto; border-radius: 8px; font-size: 0.9em; width: 90%; box-sizing: border-box; }
        .task.product-A { background: linear-gradient(45deg,#e74c3c,#c0392b); }
        .task.product-B { background: linear-gradient(45deg,#f39c12,#e67e22); }
        .task.product-C { background: linear-gradient(45deg,#9b59b6,#8e44ad); }
        .rework-indicator { background: rgba(231,76,60,0.8); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.75em; margin-left: 6px; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit,minmax(150px,1fr)); gap: 20px; margin-top: 20px; }
        .metric-card { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; text-align: center; }
        .metric-value { font-size: 1.5em; font-weight: bold; color: #3498db; }

        /* Log de Simula√ß√£o */
        .simulation-log {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 100%;
            box-sizing: border-box;
        }
        .simulation-log h2 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        .simulation-log table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        .simulation-log th, .simulation-log td {
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px;
            text-align: center;
            white-space: nowrap; /* Prevent wrapping in cells */
        }
        .simulation-log th {
            background: rgba(255,255,255,0.2);
            font-weight: bold;
        }
        .simulation-log tr:nth-child(even) {
            background: rgba(255,255,255,0.05);
        }
        .simulation-log .copy-button {
            display: block;
            margin: 0 auto;
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .simulation-log .copy-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 12px rgba(0,0,0,0.3);
        }
        .simulation-log .message-box {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        .simulation-log .message-box.show {
            opacity: 1;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .controls { flex-direction: column; align-items: center; }
            .control-group { width: 90%; justify-content: center; }
            .simulation-area { grid-template-columns: 1fr; }
            .stage { min-height: 250px; }
            .simulation-log table { font-size: 0.75em; }
            .simulation-log th, .simulation-log td { padding: 5px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîÑ Simula√ß√£o de Fluxo</h1>
        <div class="controls">
            <div class="control-group">
                <label for="tasksA">Tarefas A:</label><input id="tasksA" type="number" value="5" min="0">
                <label for="tasksB">Tarefas B:</label><input id="tasksB" type="number" value="5" min="0">
                <label for="tasksC">Tarefas C:</label><input id="tasksC" type="number" value="5" min="0">
            </div>
            <div class="control-group">
                <label for="devTime">Dev Time (dias):</label><input id="devTime" type="number" value="2" min="0.1" step="0.1">
                <label for="qaTime">QA Time (dias):</label><input id="qaTime" type="number" value="2" min="0.1" step="0.1">
                <label for="reworkRate">Retrabalho %:</label><input id="reworkRate" type="number" value="0.2" min="0" max="1" step="0.05">
                <label><input id="separateQA" type="checkbox" checked> QA separado</label>
            </div>
            <div class="control-group">
                <label for="devAvailability">Dev Disponibilidade %:</label><input id="devAvailability" type="number" value="100" min="0" max="100" step="5">
                <label for="qaAvailability">QA Disponibilidade %:</label><input id="qaAvailability" type="number" value="100" min="0" max="100" step="5">
            </div>
            <div class="control-group">
                <label for="qaHomologationDays">QA Homologa√ß√£o (dias):</label><input id="qaHomologationDays" type="number" value="4" min="0" step="1">
                <label for="qaHomologationFreq">QA Homologa√ß√£o (a cada dias):</label><input id="qaHomologationFreq" type="number" value="10" min="1" step="1">
            </div>
            <div class="control-group">
                <label for="horizonDays">Horizonte (dias):</label><input id="horizonDays" type="number" value="15" min="1" step="1">
                <span id="daysRemaining">Restam: 15</span>
            </div>
            <div class="control-group">
                <button id="startBtn">‚ñ∂Ô∏è Iniciar</button>
                <button id="pauseBtn" disabled>‚è∏Ô∏è Pausar</button>
                <button id="resetBtn">üîÑ Resetar</button>
            </div>
            <div class="control-group">
                <label>Velocidade:</label><input id="speedSlider" type="range" min="100" max="2000" value="1000"><span id="speedValue">1.0x</span>
            </div>
        </div>
        <div class="simulation-area">
            <div class="stage"><div class="stage-header"><h3>Fila Dev</h3><div id="devQueueCount" class="queue-count">0</div></div><div id="devQueue"></div></div>
            <div class="stage"><div class="stage-header"><h3>Dev</h3></div>
                <div id="dev1" class="worker idle"><strong>Dev1 (A)</strong><div id="dev1-task"></div></div>
                <div id="dev2" class="worker idle"><strong>Dev2 (A)</strong><div id="dev2-task"></div></div>
                <div id="dev3" class="worker idle"><strong>Dev3 (B)</strong><div id="dev3-task"></div></div>
                <div id="dev4" class="worker idle"><strong>Dev4 (C)</strong><div id="dev4-task"></div></div>
            </div>
            <div class="stage"><div class="stage-header"><h3>Fila QA</h3><div id="qaQueueCount" class="queue-count">0</div></div><div id="qaQueue"></div></div>
            <div class="stage"><div class="stage-header"><h3>QA</h3></div>
                <div id="qa1" class="worker idle"><strong>QA1</strong><div id="qa1-task"></div></div>
                <div id="qa2" class="worker idle"><strong>QA2</strong><div id="qa2-task"></div></div>
            </div>
            <div class="stage"><div class="stage-header"><h3>Conclu√≠do</h3><div id="completedCount" class="queue-count">0</div></div><div id="completedTasks"></div></div>
        </div>
        <div class="metrics">
            <div class="metric-card"><div id="totalTasks" class="metric-value">0</div><div>Total</div></div>
            <div class="metric-card"><div id="completedTasksVal" class="metric-value">0</div><div>Conclu√≠das</div></div>
            <div class="metric-card"><div id="throughput" class="metric-value">0</div><div>Throughput</div></div>
            <div class="metric-card"><div id="wipCount" class="metric-value">0</div><div>WIP</div></div>
            <div class="metric-card"><div id="avgCycleTime" class="metric-value">0</div><div>Cycle Time</div></div>
            <div class="metric-card"><div id="flowEfficiency" class="metric-value">0%</div><div>Ef. Fluxo</div></div>
            <div class="metric-card"><div id="devIdle" class="metric-value">0%</div><div>Dev Ocioso</div></div>
            <div class="metric-card"><div id="qaIdle" class="metric-value">0%</div><div>QA Ocioso</div></div>
            <div class="metric-card"><div id="reworkCount" class="metric-value">0</div><div>Retrab.</div></div>
        </div>

        <div class="simulation-log">
            <h2>üìä Log da √öltima Simula√ß√£o</h2>
            <div id="logTableContainer">
                <!-- Log table will be inserted here by JavaScript -->
            </div>
            <button id="copyLogBtn" class="copy-button">üìã Copiar Log para Planilha</button>
            <div id="messageBox" class="message-box">Copiado para a √°rea de transfer√™ncia!</div>
        </div>

        <div class="footer">
            <p>Desenvolvido por <strong><a href="https://www.linkedin.com/in/felipefernand10/" target="_blank">Felipe Fernandes</a></strong></p>
            <p><a href="https://github.com/felipefernandes/flowsimulator" target="_blank">Contribua com esse projeto.</a></p>
        </div>

    </div>
    <script>
        class QueueSimulation {
            constructor() {
                this.speed = 1000; // Default speed in milliseconds per day
                this.simulationInterval = null; // To store the interval ID for pausing/stopping
                this.resetState(); // Initialize the simulation state
                this.setupListeners(); // Set up event listeners for controls
            }

            // Resets all simulation variables to their initial state
            resetState() {
                this.isRunning = false; // Flag to control simulation execution
                this.taskId = 0; // Counter for unique task IDs
                this.currentDay = 0; // Current day of the simulation
                this.devQueue = []; // Queue for tasks waiting for development
                this.qaQueue = []; // Queue for tasks waiting for QA
                this.completedTasksArr = []; // Array to store completed tasks

                // Developer objects with their assigned product type, current task, work progress, and idle time
                this.developers = [
                    { id: 'dev1', product: 'A', currentTask: null, workTime: 0, idleTime: 0 },
                    { id: 'dev2', product: 'A', currentTask: null, workTime: 0, idleTime: 0 },
                    { id: 'dev3', product: 'B', currentTask: null, workTime: 0, idleTime: 0 },
                    { id: 'dev4', product: 'C', currentTask: null, workTime: 0, idleTime: 0 }
                ];

                // QA objects with their current task, work progress, idle time, homologation status, and current product focus
                this.qas = [
                    { id: 'qa1', currentTask: null, workTime: 0, idleTime: 0, isHomologating: false, homologationDaysRemaining: 0, currentProductFocus: null },
                    { id: 'qa2', currentTask: null, workTime: 0, idleTime: 0, isHomologating: false, homologationDaysRemaining: 0, currentProductFocus: null }
                ];

                // Metrics to track simulation performance
                this.metrics = {
                    totalTasks: 0,
                    completed: 0,
                    reworkCount: 0,
                    totalCycleDays: 0, // Sum of (completedDay - createdDay) for all completed tasks
                    totalDevIdleTime: 0, // Total accumulated idle time for all devs
                    totalQaIdleTime: 0   // Total accumulated idle time for all qas
                };

                // Get simulation parameters from UI inputs
                this.initialTasksA = parseInt(document.getElementById('tasksA').value);
                this.initialTasksB = parseInt(document.getElementById('tasksB').value);
                this.initialTasksC = parseInt(document.getElementById('tasksC').value);
                this.devTime = parseFloat(document.getElementById('devTime').value);
                this.qaTime = parseFloat(document.getElementById('qaTime').value);
                this.reworkRate = parseFloat(document.getElementById('reworkRate').value);
                this.devAvailability = parseInt(document.getElementById('devAvailability').value);
                this.qaAvailability = parseInt(document.getElementById('qaAvailability').value);
                this.qaHomologationDays = parseInt(document.getElementById('qaHomologationDays').value);
                this.qaHomologationFreq = parseInt(document.getElementById('qaHomologationFreq').value);
                this.horizonDays = parseInt(document.getElementById('horizonDays').value) || 15;
                this.separateQA = document.getElementById('separateQA').checked;


                this.daysUntilNextHomologationCheck = this.qaHomologationFreq; // Initialize for the first check

                // Update UI elements to reflect the reset state
                document.getElementById('daysRemaining').textContent = `Restam: ${this.horizonDays}`;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;

                // Clear any existing simulation interval
                if (this.simulationInterval) {
                    clearInterval(this.simulationInterval);
                    this.simulationInterval = null;
                }

                this.updateUI(); // Update UI to clear previous simulation visuals
                this.clearLog(); // Clear previous log data
            }

            // Sets up event listeners for buttons and sliders
            setupListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetState());
                document.getElementById('copyLogBtn').addEventListener('click', () => this.copyLogToClipboard());

                // Speed slider listener
                document.getElementById('speedSlider').addEventListener('input', e => {
                    this.speed = parseInt(e.target.value);
                    // Adjust speed display: higher slider value means slower simulation (longer interval)
                    document.getElementById('speedValue').textContent = `${((2100 - this.speed) / 1000).toFixed(1)}x`;
                    // If simulation is running, restart interval with new speed
                    if (this.isRunning) {
                        clearInterval(this.simulationInterval);
                        this.simulationInterval = setInterval(() => this.runSimulation(), this.speed);
                    }
                });

                // Horizon Days input listener to update remaining days display
                document.getElementById('horizonDays').addEventListener('input', e => {
                    this.horizonDays = parseInt(e.target.value);
                    document.getElementById('daysRemaining').textContent = `Restam: ${this.horizonDays - this.currentDay}`;
                });

                // Separate QA checkbox listener to trigger UI update
                document.getElementById('separateQA').addEventListener('change', () => this.updateUI());

                // Add listeners for new availability inputs to trigger UI update on change
                document.getElementById('devAvailability').addEventListener('input', () => this.updateUI());
                document.getElementById('qaAvailability').addEventListener('input', () => this.updateUI());
                document.getElementById('qaHomologationDays').addEventListener('input', () => this.updateUI());
                document.getElementById('qaHomologationFreq').addEventListener('input', () => this.updateUI());
            }

            // Starts the simulation
            start() {
                if (this.isRunning) return; // Prevent starting if already running

                this.resetState(); // Ensure a clean slate before starting

                // Get initial task counts from UI inputs (stored in resetState now)
                // Add initial tasks to the development queue
                for (let i = 0; i < this.initialTasksA; i++) this.addTask('A', false);
                for (let i = 0; i < this.initialTasksB; i++) this.addTask('B', false);
                for (let i = 0; i < this.initialTasksC; i++) this.addTask('C', false);

                // Disable start button, enable pause button
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                this.isRunning = true;

                // Start the simulation loop
                this.simulationInterval = setInterval(() => this.runSimulation(), this.speed);
            }

            // Pauses the simulation
            pause() {
                this.isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                clearInterval(this.simulationInterval); // Stop the simulation interval
                this.simulationInterval = null;
                this.generateLog(); // Generate log when simulation pauses
            }

            // Adds a new task to the development queue
            addTask(product, isRework) {
                const task = {
                    id: ++this.taskId,
                    product: product,
                    createdDay: this.currentDay, // Day task was created/re-entered dev queue
                    isRework: isRework,
                    devDuration: 0, // Will be set when developer picks it up
                    qaDuration: 0,  // Will be set when QA picks it up
                    completedDay: 0 // Will be set when task is completed
                };
                this.devQueue.push(task);
                this.metrics.totalTasks++;
            }

            // The main simulation loop, executed once per "day"
            runSimulation() {
                if (!this.isRunning) return; // Stop if simulation is paused

                this.currentDay++; // Advance to the next day

                // Check if simulation horizon has been reached
                if (this.currentDay > this.horizonDays) {
                    this.pause(); // Stop the simulation
                    return;
                }

                // Update days remaining display
                document.getElementById('daysRemaining').textContent = `Restam: ${this.horizonDays - this.currentDay}`;

                this.checkQAHomologation(); // Manage QA homologation periods
                this.processDevelopers(); // Process tasks in the development stage
                this.processQAs(); // Process tasks in the QA stage

                this.updateUI(); // Update the user interface to reflect current state
            }

            // Manages QA homologation periods
            checkQAHomologation() {
                // Only run if QA is separate and homologation is configured
                const separateQA = document.getElementById('separateQA').checked;
                if (!separateQA || this.qaHomologationDays <= 0 || this.qaHomologationFreq <= 0) {
                    // Ensure QAs are not in homologation if conditions are not met
                    this.qas.forEach(qa => {
                        qa.isHomologating = false;
                        qa.homologationDaysRemaining = 0;
                    });
                    return;
                }

                // Decrement days until next homologation check
                this.daysUntilNextHomologationCheck--;

                // If it's time to start a new homologation cycle
                if (this.daysUntilNextHomologationCheck <= 0) {
                    this.qas.forEach(qa => {
                        if (!qa.isHomologating) { // Only start if not already homologating
                            qa.isHomologating = true;
                            qa.homologationDaysRemaining = this.qaHomologationDays;
                            // If QA has a current task, put it back to the QA queue
                            if (qa.currentTask) {
                                this.qaQueue.unshift(qa.currentTask); // Add to the beginning of the queue
                                qa.currentTask = null;
                                qa.workTime = 0;
                            }
                        }
                    });
                    // Reset the counter for the next homologation cycle
                    this.daysUntilNextHomologationCheck = this.qaHomologationFreq;
                }

                // Decrement homologation days remaining for QAs currently homologating
                this.qas.forEach(qa => {
                    if (qa.isHomologating) {
                        qa.homologationDaysRemaining--;
                        if (qa.homologationDaysRemaining <= 0) {
                            qa.isHomologating = false; // Homologation finished
                        }
                    }
                });
            }

            // Manages tasks in the development stage
            processDevelopers() {
                const devAvailabilityRate = this.devAvailability / 100; // Convert percentage to a rate

                this.developers.forEach(dev => {
                    // Check if developer is available for production work today based on availability rate
                    if (Math.random() < devAvailabilityRate) {
                        if (dev.currentTask) {
                            // If developer has a task, increment their work time
                            dev.workTime++;
                            // Check if the task is finished
                            if (dev.workTime >= dev.currentTask.devDuration) {
                                // Always move task to QA queue after development
                                this.qaQueue.push(dev.currentTask);
                                dev.currentTask = null; // Clear task from developer
                                dev.workTime = 0; // Reset work time
                            }
                        } else {
                            // If developer is idle, try to pick up a task from the dev queue
                            let task = null;
                            // Find a task matching the developer's product type first
                            const idx = this.devQueue.findIndex(t => t.product === dev.product);
                            if (idx >= 0) {
                                task = this.devQueue.splice(idx, 1)[0]; // Remove task from queue
                            }

                            if (task) {
                                dev.currentTask = task; // Assign task to developer
                                // Assign a random duration for development when task starts
                                dev.currentTask.devDuration = (Math.random() * 4 + 3) * this.devTime;
                                dev.workTime = 0; // Reset work time for new task
                            } else {
                                // If no task available, developer remains idle
                                dev.idleTime++;
                            }
                        }
                    } else {
                        // Developer is unavailable for production work today (e.g., pre-production, meetings)
                        dev.idleTime++; // Still considered idle from production perspective
                        // If they had a task, it remains assigned but no work is done on it today
                    }
                });
            }

            // Manages tasks in the QA stage
            processQAs() {
                const separateQA = document.getElementById('separateQA').checked;
                const qaAvailabilityRate = this.qaAvailability / 100;

                this.qas.forEach(qa => {
                    // Check if QA is available for production work today AND not homologating
                    if (Math.random() < qaAvailabilityRate && !qa.isHomologating) {
                        if (qa.currentTask) {
                            // If QA has a task, increment their work time
                            qa.workTime++;
                            // Check if the QA task is finished
                            if (qa.workTime >= qa.currentTask.qaDuration) {
                                // Determine if rework is needed based on rework rate
                                if (Math.random() < this.reworkRate) {
                                    qa.currentTask.isRework = true; // Mark task as rework
                                    this.devQueue.push(qa.currentTask); // Send back to dev queue
                                    this.metrics.reworkCount++; // Increment rework count
                                } else {
                                    // Task passed QA, move to completed
                                    qa.currentTask.completedDay = this.currentDay;
                                    this.completedTasksArr.push(qa.currentTask);
                                    this.metrics.completed++;
                                    // Add cycle time (time from creation to completion)
                                    this.metrics.totalCycleDays += (qa.currentTask.completedDay - qa.currentTask.createdDay);
                                }
                                qa.currentTask = null; // Clear task from QA
                                qa.workTime = 0; // Reset work time
                                qa.currentProductFocus = null; // Clear focus as task is done
                            }
                        } else {
                            // If QA is idle, try to pick up a task from the QA queue
                            let task = null;
                            let taskIndex = -1;

                            if (separateQA) {
                                // Mode: QA separado (Product Focus)
                                // Priority 1: Continue with current product focus (if any and tasks exist)
                                if (qa.currentProductFocus) {
                                    taskIndex = this.qaQueue.findIndex(t => t.product === qa.currentProductFocus);
                                    if (taskIndex !== -1) {
                                        task = this.qaQueue.splice(taskIndex, 1)[0];
                                    }
                                }

                                // Priority 2: If no current focus or no tasks of that focus, pick the oldest task of any type
                                if (!task && this.qaQueue.length > 0) {
                                    task = this.qaQueue.shift(); // FIFO for any type
                                    if (task) { // Ensure task is not null before setting focus
                                        qa.currentProductFocus = task.product; // Set new focus
                                    }
                                }
                            } else {
                                // Mode: QA n√£o separado (FIFO)
                                if (this.qaQueue.length > 0) {
                                    task = this.qaQueue.shift(); // FIFO
                                    qa.currentProductFocus = null; // No product focus in FIFO mode
                                }
                            }

                            if (task) {
                                qa.currentTask = task; // Assign task to QA
                                // Assign a random duration for QA when task starts
                                qa.currentTask.qaDuration = (Math.random() * 2 + 1) * this.qaTime; // QA time usually shorter
                                qa.workTime = 0; // Reset work time for new task
                            } else {
                                // If no task available, QA remains idle
                                qa.idleTime++;
                                if (separateQA) { // Clear focus if no tasks to work on in product-focus mode
                                    qa.currentProductFocus = null;
                                }
                            }
                        }
                    } else {
                        // QA is unavailable for production work today (due to availability % or homologation)
                        qa.idleTime++; // Still considered idle from production perspective
                        // If they had a task, it remains assigned but no work is done on it today
                    }
                });
            }

            // Updates all visual elements of the simulation in the UI
            updateUI() {
                const separateQA = document.getElementById('separateQA').checked;

                // Update Queue Counts
                document.getElementById('devQueueCount').textContent = this.devQueue.length;
                // QA queue count is always displayed now
                document.getElementById('qaQueueCount').textContent = this.qaQueue.length;
                document.getElementById('completedCount').textContent = this.metrics.completed;

                // Render Dev Queue tasks
                const devQueueEl = document.getElementById('devQueue');
                devQueueEl.innerHTML = ''; // Clear existing tasks
                this.devQueue.forEach(task => {
                    const taskEl = document.createElement('div');
                    taskEl.className = `task product-${task.product}`;
                    taskEl.textContent = `Tarefa ${task.id} (${task.product})`;
                    if (task.isRework) {
                        const reworkSpan = document.createElement('span');
                        reworkSpan.className = 'rework-indicator';
                        reworkSpan.textContent = 'RETRAB.';
                        taskEl.appendChild(reworkSpan);
                    }
                    devQueueEl.appendChild(taskEl);
                });

                // Render QA Queue tasks (always rendered now)
                const qaQueueEl = document.getElementById('qaQueue');
                qaQueueEl.innerHTML = ''; // Clear existing tasks
                this.qaQueue.forEach(task => {
                    const taskEl = document.createElement('div');
                    taskEl.className = `task product-${task.product}`;
                    taskEl.textContent = `Tarefa ${task.id} (${task.product})`;
                    if (task.isRework) {
                        const reworkSpan = document.createElement('span');
                        reworkSpan.className = 'rework-indicator';
                        reworkSpan.textContent = 'RETRAB.';
                        taskEl.appendChild(reworkSpan);
                    }
                    qaQueueEl.appendChild(taskEl);
                });

                // Update Developers' status and current task display
                this.developers.forEach(dev => {
                    const devEl = document.getElementById(dev.id);
                    const devNameEl = devEl.querySelector('strong'); // Get the strong tag
                    const devTaskEl = document.getElementById(`${dev.id}-task`);
                    const devAvailabilityRate = this.devAvailability / 100;

                    // Reset classes
                    devEl.classList.remove('idle', 'working', 'unavailable');

                    // Update Dev name with product specialization
                    devNameEl.textContent = `${dev.id.replace('dev', 'Dev')} (${dev.product})`;

                    // Determine status
                    let statusText = '';
                    if (dev.currentTask) {
                        devEl.classList.add('working');
                        statusText = `Trabalhando na Tarefa ${dev.currentTask.id} (${dev.currentTask.product})<br>(${dev.workTime.toFixed(1)}/${dev.currentTask.devDuration.toFixed(1)} dias)`;
                    } else {
                        // For display purposes, we'll run the random check again.
                        // This random check here is purely for visual representation of "unavailable" status
                        // and doesn't affect the actual work logic which is done in processDevelopers().
                        if (Math.random() >= devAvailabilityRate) {
                            devEl.classList.add('unavailable');
                            statusText = 'Indispon√≠vel (Outras Tarefas)';
                        } else {
                            devEl.classList.add('idle');
                            statusText = 'Ocioso';
                        }
                    }
                    devTaskEl.innerHTML = statusText;
                });

                // Update QAs' status and current task display
                this.qas.forEach(qa => {
                    const qaEl = document.getElementById(qa.id);
                    const qaNameEl = qaEl.querySelector('strong'); // Get the strong tag
                    const qaTaskEl = document.getElementById(`${qa.id}-task`);
                    const qaAvailabilityRate = this.qaAvailability / 100;

                    // Reset classes
                    qaEl.classList.remove('idle', 'working', 'unavailable');

                    // Update QA name with current product focus or FIFO indication
                    const focusText = separateQA ? (qa.currentProductFocus ? `Foco: ${qa.currentProductFocus}` : 'Nenhum Foco') : 'FIFO';
                    qaNameEl.textContent = `${qa.id.replace('qa', 'QA')} (${focusText})`;

                    let statusText = '';
                    if (qa.isHomologating) {
                        qaEl.classList.add('unavailable');
                        statusText = `Em Homologa√ß√£o (${qa.homologationDaysRemaining} dias rest.)`;
                    } else if (qa.currentTask) {
                        qaEl.classList.add('working');
                        statusText = `Trabalhando na Tarefa ${qa.currentTask.id} (${qa.currentTask.product})<br>(${qa.workTime.toFixed(1)}/${qa.currentTask.qaDuration.toFixed(1)} dias)`;
                    } else {
                        // If not working and not homologating, check if they are "unavailable" based on daily random check
                        // Similar to Devs, this is for visual representation.
                        if (Math.random() >= qaAvailabilityRate) {
                            qaEl.classList.add('unavailable');
                            statusText = 'Indispon√≠vel (Outras Tarefas)';
                        } else {
                            qaEl.classList.add('idle');
                            statusText = 'Ocioso';
                        }
                    }
                    qaTaskEl.innerHTML = statusText;
                });

                // Render Completed Tasks
                const completedTasksEl = document.getElementById('completedTasks');
                completedTasksEl.innerHTML = ''; // Clear existing tasks
                this.completedTasksArr.forEach(task => {
                    const taskEl = document.createElement('div');
                    taskEl.className = `task product-${task.product}`;
                    taskEl.textContent = `Tarefa ${task.id} (${task.product}) - Conclu√≠da no dia ${task.completedDay}`;
                    completedTasksEl.appendChild(taskEl);
                });

                // Update Metrics
                document.getElementById('totalTasks').textContent = this.metrics.totalTasks;
                document.getElementById('completedTasksVal').textContent = this.metrics.completed;
                document.getElementById('reworkCount').textContent = this.metrics.reworkCount;

                // Throughput: completed tasks per day
                const throughput = this.currentDay > 0 ? (this.metrics.completed / this.currentDay).toFixed(2) : 0;
                document.getElementById('throughput').textContent = throughput;

                // WIP (Work In Progress): Tasks in queues + tasks being worked on
                const wip = this.devQueue.length + this.qaQueue.length + // QA queue is always counted now
                            this.developers.filter(dev => dev.currentTask).length +
                            this.qas.filter(qa => qa.currentTask).length; // QA workers are always counted now
                document.getElementById('wipCount').textContent = wip;

                // Average Cycle Time: total cycle days / completed tasks
                const avgCycleTime = this.metrics.completed > 0 ? (this.metrics.totalCycleDays / this.metrics.completed).toFixed(2) : 0;
                document.getElementById('avgCycleTime').textContent = avgCycleTime;

                // Flow Efficiency: (Actual work time / Total Cycle Time) * 100
                let totalActualWorkTime = 0;
                this.completedTasksArr.forEach(task => {
                    totalActualWorkTime += (task.devDuration || 0); // Dev work time
                    totalActualWorkTime += (task.qaDuration || 0); // QA work time is always added now
                });
                const totalTimeInSystem = this.metrics.completed > 0 ? this.metrics.totalCycleDays : 0;

                const flowEfficiency = totalTimeInSystem > 0 ? ((totalActualWorkTime / totalTimeInSystem) * 100).toFixed(2) : 0;
                document.getElementById('flowEfficiency').textContent = `${flowEfficiency}%`;

                // Update total idle times for metrics calculation at the end
                this.metrics.totalDevIdleTime = this.developers.reduce((sum, dev) => sum + (dev.idleTime || 0), 0);
                this.metrics.totalQaIdleTime = this.qas.reduce((sum, qa) => sum + (qa.idleTime || 0), 0);

                // Idle time percentages for Devs and QAs
                const totalDevWorkCapacity = this.currentDay * this.developers.length;
                const totalQaWorkCapacity = this.currentDay * this.qas.length;

                const devIdlePercentage = totalDevWorkCapacity > 0 ? ((this.metrics.totalDevIdleTime / totalDevWorkCapacity) * 100).toFixed(2) : 0;
                const qaIdlePercentage = totalQaWorkCapacity > 0 ? ((this.metrics.totalQaIdleTime / totalQaWorkCapacity) * 100).toFixed(2) : 0;

                document.getElementById('devIdle').textContent = `${devIdlePercentage}%`;
                document.getElementById('qaIdle').textContent = `${qaIdlePercentage}%`;
            }

            // Generates the log table for Google Sheets
            generateLog() {
                const logTableContainer = document.getElementById('logTableContainer');
                logTableContainer.innerHTML = ''; // Clear previous log

                // Collect current values for the log
                const backlogA = this.initialTasksA;
                const backlogB = this.initialTasksB;
                const backlogC = this.initialTasksC;
                const cycletimeDev = this.devTime;
                const cycletimeQA = this.qaTime;
                const reworkRate = this.reworkRate;
                const dispDev = this.devAvailability;
                const dispQA = this.qaAvailability;
                const cycleTimeHomolog = this.qaHomologationDays;
                const freqHomolog = this.qaHomologationFreq;
                const itemsConcluidos = this.metrics.completed;
                const vazao = this.currentDay > 0 ? (this.metrics.completed / this.currentDay).toFixed(2) : 0;
                const wip = this.devQueue.length + this.qaQueue.length +
                            this.developers.filter(dev => dev.currentTask).length +
                            this.qas.filter(qa => qa.currentTask).length;
                const cycleTime = this.metrics.completed > 0 ? (this.metrics.totalCycleDays / this.metrics.completed).toFixed(2) : 0;
                let totalActualWorkTime = 0;
                this.completedTasksArr.forEach(task => {
                    totalActualWorkTime += (task.devDuration || 0);
                    totalActualWorkTime += (task.qaDuration || 0);
                });
                const totalTimeInSystem = this.metrics.completed > 0 ? this.metrics.totalCycleDays : 0;
                const flowEfficiency = totalTimeInSystem > 0 ? ((totalActualWorkTime / totalTimeInSystem) * 100).toFixed(2) : 0;

                const totalDevWorkCapacity = this.currentDay * this.developers.length;
                const totalQaWorkCapacity = this.currentDay * this.qas.length;
                const devIdlePercentage = totalDevWorkCapacity > 0 ? ((this.metrics.totalDevIdleTime / totalDevWorkCapacity) * 100).toFixed(2) : 0;
                const qaIdlePercentage = totalQaWorkCapacity > 0 ? ((this.metrics.totalQaIdleTime / totalQaWorkCapacity) * 100).toFixed(2) : 0;
                const retrabalhoBugs = this.metrics.reworkCount;

                const scenarioName = this.separateQA ? "QA Foco por produto" : "QA FIFO";

                const logData = [
                    scenarioName,
                    backlogA,
                    backlogB,
                    backlogC,
                    cycletimeDev,
                    cycletimeQA,
                    reworkRate,
                    dispDev,
                    dispQA,
                    cycleTimeHomolog,
                    freqHomolog,
                    itemsConcluidos,
                    vazao,
                    wip,
                    cycleTime,
                    `${flowEfficiency}%`,
                    `${devIdlePercentage}%`,
                    `${qaIdlePercentage}%`,
                    retrabalhoBugs
                ];

                const headers = [
                    "Cen√°rios", "Backlog A (tasks)", "Backlog B (tasks)", "Backlog C (tasks)",
                    "Cycletime Dev (dias)", "Cycletime QA (dias)", "Densidade de Defeitos (bugs/task)",
                    "Disp. Dev %", "Disp. QA %", "Cycle Time Homolog (dias)", "Freq Homolog (dias)",
                    "Itens conclu√≠dos", "Vaz√£o (itens/dia)", "WIP (itens)", "Cycle Time (dias)",
                    "EF%", "Ocioso Dev %", "Ocioso QA %", "Retrabalho (Bugs)"
                ];

                let tableHTML = '<table><thead><tr>';
                headers.forEach(header => {
                    tableHTML += `<th>${header}</th>`;
                });
                tableHTML += '</tr></thead><tbody><tr>';
                logData.forEach(data => {
                    tableHTML += `<td>${data}</td>`;
                });
                tableHTML += '</tr></tbody></table>';

                logTableContainer.innerHTML = tableHTML;
            }

            // Clears the log table
            clearLog() {
                document.getElementById('logTableContainer').innerHTML = '';
            }

            // Copies the log table data to clipboard
            copyLogToClipboard() {
                const table = document.querySelector('.simulation-log table');
                if (!table) {
                    this.showMessage("Nenhum log para copiar.");
                    return;
                }

                let csv = [];
                const rows = table.querySelectorAll('tr');

                for (let i = 0; i < rows.length; i++) {
                    const row = [], cols = rows[i].querySelectorAll('td, th');
                    for (let j = 0; j < cols.length; j++) {
                        // Remove HTML tags from content for plain text copy
                        row.push(cols[j].innerText.replace(/\s+/g, ' ').trim());
                    }
                    csv.push(row.join('\t')); // Use tab for easy pasting into Sheets
                }

                const csvString = csv.join('\n');

                // Use document.execCommand('copy') for better compatibility in iframes
                const textArea = document.createElement('textarea');
                textArea.value = csvString;
                textArea.style.position = 'fixed'; // Avoid scrolling to bottom
                textArea.style.left = '-9999px'; // Hide from view
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();

                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        this.showMessage("Copiado para a √°rea de transfer√™ncia!");
                    } else {
                        this.showMessage("Falha ao copiar o log.");
                    }
                } catch (err) {
                    this.showMessage("Erro ao copiar: " + err);
                } finally {
                    document.body.removeChild(textArea);
                }
            }

            // Displays a temporary message box
            showMessage(message) {
                const msgBox = document.getElementById('messageBox');
                msgBox.textContent = message;
                msgBox.classList.add('show');
                setTimeout(() => {
                    msgBox.classList.remove('show');
                }, 2000); // Message disappears after 2 seconds
            }
        }

        // Initialize the simulation when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            new QueueSimulation();
        });
    </script>
</body>
</html>
